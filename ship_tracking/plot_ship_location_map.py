#!/usr/bin/env python
#RMS 2018
#Wrapper for the ship location plotting maps

import os 
import pandas as pd
import obspy as op
import requests
from obspy.geodetics import gps2dist_azimuth
import datetime
import sys
import numpy as np

def main():

	'''
	Reads the spreadsheet of station locations (already ordered according to planned vists),
	gets the current ship location. Determines distance to nearest station and plots map.

	To get this to work, you need the following:
	> All the python libraries above
	> Connection to sikuliaq wifi
	> A .csv file in the format of station_data_notes.csv. Importantly, the stations 
	must be ordered according to when they will be visited. Check the format of this file if unsure
	> The file SIKULIAQ_track.dat. This is generated by Sikuliaq_Cruise_get_location.py. The .dat file 
	is where the ship location information is stored

	Known issues

	> Note that a station is classified as 'visited' if the ship comes within 2km of it.
	In some situations (e.g. co-located GPSA and OBS) this may not be the case and you will have to
	manually remove the station from visited_stations.dat
	> The ship track is updated everytime this code is run. If stations are visited between times 
	that the code is run, they will have to be manually entered and the ship track manually updated

	'''

	#Get event locations in the region (only when connected to the internet)
	#get_earthquakes(allquakes=True)
	#sys.exit(1)

	locations = pd.read_csv("station_data_notes.csv")

	#Attempt to get location from ship tracker site. This doesn't usually work! 

	response = requests.get("https://web.sikuliaq.alaska.edu/track/?REFRESH=60")
	page = response.content
	table = pd.read_html(page)[0]
	shiplat = float(table[1][1].split(' ')[2])
	shiplon = -float(table[1][2].split(' ')[1])
	shipspeed = float(table[4][2].split()[0])
	shipheading = heading = float(table[3][1].split()[2])

	record_time = table[0][1].split(':')
	update_time = table[0][2].split(':')

	Rtime = op.UTCDateTime('-'.join([record_time[1].split("@")[0].strip(),
                            record_time[1].split("@")[1].strip(),
                            record_time[2],record_time[3].split(' ')[0]]))
	Utime = op.UTCDateTime('-'.join([update_time[1].split("@")[0].strip(),
                            update_time[1].split("@")[1].strip(),
                            update_time[2],update_time[3].split(' ')[0]]))

	#If method 1 to get ship location fails, try method 2

	if abs(Rtime-Utime) > 600:

		print("Regular shiptrack site hasn't updated for > 10 mins. Trying alternative")

		base_url="http://data.sikuliaq.alaska.edu/archive/SKQ201811S/lds/raw/pco2_ldeo_merge/"
		response = requests.get(base_url)
		page = response.content
		table = pd.read_html(page)[0]
		fname = table.loc[len(table)-1][1]
		response = requests.get(base_url+fname)
		page = str(response.content)
		sdata = page.split('\n')[-2]

		latval = sdata.split(',')[11].strip().split()[0]
		lonval = sdata.split(',')[12].strip().split()[0]
		shiplat = float(latval[:2]) + float(latval[2:])/60
		shiplon = -1*(float(lonval[:3]) + float(lonval[3:])/60)
		shipspeed = float(sdata.split(',')[-6])*1.852 #conversion from knots to km/h
		shipheading = np.nan


	print("Current ship location: %s,%s" %(shiplon,shiplat))

	#Append current location to the track file
	trackfile = open("SIKULIAQ_track.dat",'a')
	trackfile.write('%s,%s,%s,%s,%s,%s\n' %(Rtime,Utime,shiplon,shiplat,shipheading,shipspeed))
	trackfile.close()

	locations['Distance_from_ship'] = locations.apply(lambda row: 
                    get_distance(row['Lon'],row['Lat'],shiplon,shiplat),axis=1)\

	#Generate df of closest stations
	closest_stations = locations.sort_values('Distance_from_ship')
	closest_stations.reset_index(inplace=True)

	#Check if we have visited any stations. A visit is defined as coming within 2 km of any station
	if not os.path.exists('Visited_stations.dat'):

		visited_stations = open('Visited_stations.dat','w')

	else:

		visited_stations = open('Visited_stations.dat','a')	

	if (closest_stations.loc[0]['Distance_from_ship'] < 2):

		visited_stations.write('%s,%s,%s,%s\n' %(closest_stations.loc[0]['Lon'],closest_stations.loc[0]['Lat'],
			closest_stations.loc[0]['Type'],closest_stations.loc[0]['Name']))

	visited_stations.close()

	visited_stations = open('Visited_stations.dat','r')	

	#Read the visted stations file and use this to update the definition of 'next station'

	lines = visited_stations.readlines()

	visited_stations.close()

	#Read the visited stations into a list, which we can compare to the list of stations to visit

	visited_stations_list = None

	if len(lines) >= 1:

		visited_stations_list = []

		for line in lines:
			station_info = line.split(',')
			station_name = station_info[-1].strip()
			if station_name not in visited_stations_list:
				visited_stations_list.append(station_name)

	#print(visited_stations_list)

	#lists of the stations in order of planned visits
	stations_to_visit = list(locations['Name'])
	station_types_to_vist = list(locations['Type'])
	#print(stations_to_visit)

	#Now, find the next station using the given order and the list of visited stations we just made

	if len(stations_to_visit) == len(visited_stations_list):
		next_station = 'Seward'
		next_station_type = 'Heading_back_to_port'
		next_station_distance = "Undefined"
		os.system('./cruise_area_map.sh %s %s %s %s %s' %(next_station,next_station_type,
			next_station_distance,shipspeed,shipheading))
	else:
		next_station = stations_to_visit[0]
		next_station_type = station_types_to_vist[0]

		if visited_stations_list:

			i = 0
			for station_code in stations_to_visit:
				#print(i)

				if station_code in visited_stations_list:
						#print(station_code)
						i += 1 
				else:
					next_station = stations_to_visit[i]
					next_station_type = station_types_to_vist[i]
					
					#print(next_station)
					break

		print("I think the next station is %s (check if unsure)" %(next_station))

		#Write the next station information to file
		next_station_info = locations[locations['Name']==next_station]
		next_station_lon = next_station_info['Lon'].values[0]
		next_station_lat = next_station_info['Lat'].values[0]
		next_station_depth = next_station_info['Depth'].values[0]

		next_station_file = open('next_station_coords.dat','w')
		next_station_file.write('%s %s' %(next_station_lon,next_station_lat))
		next_station_file.close()

		#Get the distance to the next station
		next_station_distance = next_station_info['Distance_from_ship'].values[0]

		#Determine whether we need to check the bathymetry at the next station
		next_station_bathy = next_station_info['check_bathy'].values[0]

		if next_station_bathy == 1:
			print("Need to check bathymetry at next station")
		elif next_station_bathy == 2:
			print("Really need to check bathymetry at the next station")
		else:
			print("Bathymetry at next site is well known")

		#Run the GMT script to plot the ship location
		try:
			next_station_type = "_".join(next_station_type.split())
		except:
			next_station_type = "Unknown_type"

		os.system('./cruise_area_map.sh %s %s %02d %s %s' %(next_station,next_station_type,
			float(next_station_distance),shipspeed,shipheading))

		print('--------------------------------------------')
		print("Next station distance: %03d km" %next_station_distance)
		print('--------------------------------------------')
		print("Estimated time of arrival at next station:")
		print(ETA(float(shipspeed),float(next_station_distance)))
		print('--------------------------------------------')
		print("ETA at next station assuming mean speed of 18.5km/h:")
		print(ETA(18.5,float(next_station_distance)))
		print('--------------------------------------------')

		#If this is the case the next station is not a TRM and so might need ranging
		if 'T' not in next_station:
			sink_time = abs(next_station_depth)/40.0 #aprox 40 meters/minute
			print("Sink time of next station is aprox. %03d minutes" %sink_time)



def get_distance(lon,lat,shiplon,shiplat):
    
    (dist,az,baz) = gps2dist_azimuth(shiplat,shiplon,lat,lon)
    
    return dist/1000.0

def get_az(lon,lat,shiplon,shiplat):
    
    (dist,az,baz) = gps2dist_azimuth(shiplat,shiplon,lat,lon)
    
    return az

def ETA(speed,distance):

	'''
	Get the estimated time of arrival at some distance
	'''

	if speed < 1:

		return 'Undefined'

	else:

		today = op.UTCDateTime(datetime.datetime.today())

		return (today + (distance/speed)*3600)

def get_earthquakes(allquakes=False):

	'''
	Get all events that have occured in the cruise region since the arrival date
	'''

	print("Getting events for cruise region")

	from obspy.fdsn import Client as fdsnClient
	client = fdsnClient('IRIS')

	if allquakes == True:
		arrival_day = op.UTCDateTime('1970-01-01')
	else:
		arrival_day = op.UTCDateTime('2018-05-06')

	now = op.UTCDateTime(datetime.datetime.today())

	quakecat = client.get_events(starttime=op.UTCDateTime(arrival_day), endtime=op.UTCDateTime(now), 
		minlongitude=-163, maxlongitude=-148, minlatitude=52.5, maxlatitude=58.5, minmagnitude=0)

	if allquakes == True:
		quakefile = open("Events_since_1970.dat",'w')
	else:
		quakefile = open("Events_since_cruise.dat",'w')

	for event in quakecat:
		lon = event.origins[0].longitude
		lat = event.origins[0].latitude
		mag = event.magnitudes[0].mag
		try:
			dep = event.origins[0].depth
		except:
			dep = np.NaN
		quakefile.write("%s %s %s %s\n" %(lon,lat,dep,mag))

	quakefile.close()



if __name__ == '__main__':

	main()
